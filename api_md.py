"""Generates API documentation file out of docstrings."""
import inspect
from io import TextIOWrapper
from types import FunctionType
import typing
import msrc.appconfig as pkg


def writelines(f: TextIOWrapper, strings: typing.List[str]):
    for s in strings:
        f.writelines([s, '\n'])


# The below code has been taken
# from https://www.python.org/dev/peps/pep-0257/#id18
# with sys.maxint replaced by 65535
def trim(docstring: str):
    if not docstring:
        return ''
    # Convert tabs to spaces (following the normal Python rules)
    # and split into a list of lines:
    lines = docstring.expandtabs().splitlines()
    # Determine minimum indentation (first line doesn't count):
    indent = 65535
    for line in lines[1:]:
        stripped = line.lstrip()
        if stripped:
            indent = min(indent, len(line) - len(stripped))
    # Remove indentation (first line is special):
    trimmed = [lines[0].strip()]
    if indent < 65535:
        for line in lines[1:]:
            trimmed.append(line[indent:].rstrip())
    # Strip off trailing and leading blank lines:
    while trimmed and not trimmed[-1]:
        trimmed.pop()
    while trimmed and not trimmed[0]:
        trimmed.pop(0)
    # Return a single string:
    return '\n'.join(trimmed)


def summary_row(fn: FunctionType):
    n = fn.__name__
    doc = fn.__doc__ or ''
    d = next(
        (line for line in doc.splitlines() if len(line) > 0),
        "(no description)")
    return f"| [{n}](#{n}) | {d} |"


def annotation2str(annotation: object) -> str:
    if isinstance(annotation, type):
        return annotation.__name__
    else:
        return str(annotation).replace("typing.", "")


def write_fun(fn: FunctionType, f: TextIOWrapper):
    writelines(f, ['', f"## {fn.__name__}", "```python",
                   f"def {pkg.__name__}.{fn.__name__}("])
    sig: inspect.Signature = inspect.signature(fn)
    for i, n in enumerate(sig.parameters):
        p = sig.parameters[n]
        if p.annotation is not inspect.Parameter.empty:
            n += ": " + annotation2str(p.annotation)
        if p.default is not inspect.Parameter.empty:
            n += " = " + repr(p.default)
        if i < len(sig.parameters):
            n += ","
        writelines(f, ["    " + n])
    closing = ")"
    if sig.return_annotation is not inspect.Signature.empty:
        closing += " -> " + annotation2str(sig.return_annotation)
    writelines(f, [closing, "```", trim(fn.__doc__ or '')])


if __name__ == "__main__":
    with open("API.md", "w", encoding="utf8") as f:
        writelines(f, [
            f"<!--\n    THIS FILE HAS BEEN AUTO-GENERATED BY {__file__}\n-->",
            f"# {pkg.__name__}", '', trim(pkg.__doc__), '',
            '| Functions | |', '| --- | --- |'])
        writelines(f, [
            summary_row(getattr(pkg, fn)) for fn in pkg.__all__
            if callable(getattr(pkg, fn))])
        for name in pkg.__all__:
            obj = getattr(pkg, name)
            if callable(obj):
                write_fun(obj, f)
            else:
                print("Skipped", name)
